#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  HTServo,  none)
#pragma config(Sensor, S3,     ultra1,         sensorSONAR)
#pragma config(Sensor, S4,     ultra0,         sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorFrontLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorBackLeft, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     harvester,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     coveyor,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     motorBackRight, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorFrontRight, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    grabber,              tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_2,    utlraServo0,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    ultraServo1,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_1,    lift1,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C3_2,    lift2,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C3_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define AUTO_COMPETITION

#include "JoystickDriver.c"
#include "paths/Ramp.c"

/* Autonomous.c
   Final layer of abstraction
*/
typedef struct {
	string strings[16];
	int len;
} Options;

void createTeleopConfigFile(string &sExecutableName);
void finalCheck();
int selectInt(const string label, int prev);
int selectString(Options s, const string label, int prev);

task main() {
	nNxtExitClicks = 3;

	string teleopFileName = "TeleOp.c";
	const int NUM_PATHS = 2;
	Options PATHS;
	PATHS.strings[0] = "Ramp";
	//PATHS.strings[1] = "Parking";
	PATHS.len = 1;

	fullStop();
	while(true) {
		nxtDisplayCenteredTextLine(2, "%d", SensorValue[ultra0]);
		wait1Msec(5);
	}
	/*int angle = 0;
	int direction = 1;
	bool sawit = false;
	turnUltra(0, 0);
	wait1Msec(1000);
	for(int angle = 0; angle < 125; angle++) {
		writeDebugStreamLine("%d", SensorValue[ultra0]);
		if(!sawit && SensorValue[ultra0] < 100) {
			writeDebugStreamLine("Detected at %d", angle);
			sawit = true;
		}
		if(sawit && SensorValue[ultra0] > 100) {
			writeDebugStreamLine("Lost detection at %d", angle);
			sawit = false;
		}
		turnUltra(0, angle);
		wait1Msec(100);
	}*/
}



/*int forwards = 10;
	int right = 0;
	int angleSum = 0;
	int angle = 90;
	int aboveCt = 0;
	int belowCt = 0;
	const int threshold = 100;
	int direction = 1;
	bool onTube = false;
	int avg = -1;
	int distance = -1;
	int closestDistance = 255;
	int previousTubeEdge;
	float c;
	float tubeCenter;
	while(true) {
		//writeDebugStreamLine("%f", c);
		writeDebugStreamLine("%d", SensorValue[ultra0]);
		if(angle < 0 || angle > 125) {
			direction *= -1;
		}

		if(SensorValue[ultra0] < threshold)
			distance = SensorValue[ultra0];

		if(SensorValue[ultra0] < threshold) {
			aboveCt = 0;
			belowCt++;
		}
		if(SensorValue[ultra0] > threshold) {
			belowCt = 0;
			aboveCt++;
		}
		if(!onTube && belowCt > 0) {
			onTube = true;
		}
		if(onTube && aboveCt > 0) {
			onTube = false;

			tubeCenter = (angle + previousTubeEdge)/2.0;
			c = distance * cos(PI - tubeCenter * PI/180.0);
			previousTubeEdge = angle;

			direction *= -1;
		}

		angle += direction;
		turnUltra(0, angle);
		wait1Msec(25);
	}
	for(int i = 30; i < 120; i++) {
		turnUltra(0, i);
		wait1Msec(100);
		writeDebugStreamLine("(%d, %d)", i, SensorValue[ultra0]);
	}
	turnUltra(0, 0);
	turnUltra(1, 0);
	wait10Msec(10);*/

	const int MENU_ENTRIES = 3;
	int delay = 0;
	int path = 0;
	int step = 0;
	int j=0;
	while(step < MENU_ENTRIES) {
		if(nNxtButtonPressed == 0) step--;
		if(nNxtButtonPressed == 3) step++;
		if(nNxtButtonPressed!= -1) wait1Msec(200); // give time to lift off finger

		if(step == -1)
			return;
		else if(step == 0) {
			path = selectString(PATHS, "Path", path);
		}
		else if(step == 1) {
			delay = selectInt("Delay", delay);
		}
		else if(step == 2) {
			nxtDisplayCenteredTextLine(2, "Adjust Spinner");
			if(nNxtButtonPressed == 1)
				motor[spinner] = 100;
			else if(nNxtButtonPressed == 2)
				motor[spinner] = -100;
			else
				motor[spinner] = 0;
		}
		else {
			finalCheck();
		}
	}
	nxtDisplayCenteredTextLine(2, "Ready! %ds", delay);
	//createTeleopConfigFile(teleopFileName);
	waitForStart();
	pause(delay);
	Ramp();
}

// snagged from ProgramChooser.c
void createTeleopConfigFile(string &sExecutableName)
{
	char sTextFileName[] = "FTCConfig.txt"; // Name of the file containg tele-op name

	TFileIOResult nIoResult;
	TFileHandle hFileHandle;
	short nFileSize;

	// Erase existing file
  do // Make a loop in case, due to error, there are multiple copies
  {
  	Delete(sTextFileName, nIoResult);
  } while (nIoResult == ioRsltSuccess);

  // Create the file
  nFileSize = strlen(sExecutableName) + 4;
  OpenWrite(hFileHandle, nIoResult, sTextFileName, nFileSize);
  WriteText(hFileHandle, nIoResult, sExecutableName);
  WriteText(hFileHandle, nIoResult, ".rxe");
  Close(hFileHandle, nIoResult);

  // Display Message
  string sMessage = (nIoResult == ioRsltSuccess) ? "File Created" : "File Error";
  //displayCommandProgress(sMessage);
  nxtDisplayCenteredTextLine(2, "%s", sMessage);
  return;
}

int selectInt(const string label, int prev) {
	int i = prev;
	nxtDisplayCenteredTextLine(2, "%s: %d", label, i);
	if(nNxtButtonPressed == 1) i++;
	if(nNxtButtonPressed == 2) i--;
	if(nNxtButtonPressed != -1) wait1Msec(200);
	if(i<0) i = 0;
	return i;
}

int selectString(Options s, const string label, int prev) {
	int i = prev;
	int len = s.len - 1;
	nxtDisplayCenteredTextLine(2, "%s: %s", label, s.strings[i]);
	if(nNxtButtonPressed == 1) i++;
	if(nNxtButtonPressed == 2) i--;
	if(nNxtButtonPressed != -1) wait1Msec(200);
	if(i<0) i = len;
	if(i>len) i = 0;
	return i;
}

void finalCheck() {
	return;
}
