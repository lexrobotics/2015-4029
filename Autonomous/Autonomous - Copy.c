#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     backUltra,      sensorSONAR)
#pragma config(Sensor, S3,     frontUltra,     sensorSONAR)
#pragma config(Sensor, S4,     HTIRS2,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     liftMotors,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotors,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightMotors,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinner,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftStageOne,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     liftStageTwo,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    bucketGate,           tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_5,    bucketTilt,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    grabber,              tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "../Common/basicMovement.c"
#define robotLength 12.0

void grabTube(){
	servo[grabber] = 100;
	pause(2);
}
void releaseTube(){
	servo[grabber] = 0;
	pause(1);
}
void tillBack(int speed,bool sees){
	//Takes in a speed and a sees boolean.
	//This ends when the back ultra sonic either sees something or doesn't
	//see something depending on the sees boolean
	move(speed);
	if(sees){
		while(SensorValue[backUltra] >225){};
	}
	else{
		while(SensorValue[backUltra] <225){};
	}
	move(0);
}

void tillBackWithFilter(int speed,bool sees){
	//Takes in a speed and a sees boolean.
	//This ends when the back ultra sonic either sees something or doesn't
	//see something depending on the sees boolean
	move(speed);
	if(sees){
		while(true){
			while(SensorValue[backUltra] > 225){};
			int dist = SensorValue[backUltra];
			turnUltra(atan2(18,dist)+10);
			if(SensorValue[backUltra]>225){
				turnUltra(0);
				while(SensorValue[backUltra] < 225){};
				break;
			}

		}
	}
	else{
		while(SensorValue[backUltra] <225){};
	}
	move(0);
}
void tillFront(int speed, bool sees){
	//Takes in a speed and a sees boolean.
	//This ends when the back ultra sonic either sees something or doesn't
	//see something depending on the sees boolean
	move(speed);
	if(sees){
		while(SensorValue[backUltra] >225){};
	}
	else{
		while(SensorValue[backUltra] <225){};
	}
	move(0);
}
bool tooClose(int threshold){
	//Sees if it is too close to drive in and get closer
	return ((SensorValue[frontUltra] + SensorValue[backUltra])/2 < threshold);
}
/*
void parallel(int speed){
	//Parrallells the robot. Threshold is the closeness of the sensors
	while(SensorValue[frontUltra] > SensorValue[backUltra]){
		turn(speed);
	}

	while(SensorValue[backUltra] > SensorValue[frontUltra]){
		turn(-speed);
	}
}
*/

void parallel(int speed){
	//Parrallells the robot. Threshold is the closeness of the sensors
	while(abs(SensorValue[frontUltra] - SensorValue[backUltra]) > 1) {
		if(SensorValue[frontUltra] > SensorValue[backUltra]){
			turn(-speed);
		}
		else {
			turn(speed);
		}
	}
}
void knockdown(){
	//drives in turns knockdowns the kickstand and proceeds to end of wall
	float dist = (SensorValue[frontUltra] + SensorValue[backUltra])/2 - 20;
	tillBack(-50, false);
	pause(1);
	turnDistance(-45, 90);
	moveDistance(50, dist/2.5);
	pause(1);
	turnDistance(50, 90);
	tillFront(100,true);
	parallel(45);
	moveDistance(100,72);
	tillFront(100,false);
}
void kickstand(){
	tillBackWithFilter(50,true);
	pause(0.5);
	parallel(45);
	moveDistance(45,5);
	if(SensorValue[frontUltra]>225){
		//position 1
		pause(100);
		tillFront(-50,false);
		turnDistance(45,90);
		tillFront(-50,true);
		parallel(45);
		tillBack(-100,false);
	}
	else{
		if(tooClose(10)){
			tillBack(100,false);
			return;
		}
		knockdown();
	}
	//nxtDisplayCenteredTextLine(2,"angle: %f ", 90-radiansToDegrees(atan2(diff, robotLength)));
}
void reverseKnockdown(){
	//drives in turns knockdowns the kickstand and proceeds to end of wall
	float dist = (SensorValue[frontUltra] + SensorValue[backUltra])/2 - 20;
	tillFront(-50, false);
	pause(1);
	turnDistance(45, 90);
	moveDistance(-50, dist/2.5);
	pause(1);
	turnDistance(-50, 90);
	tillBack(-100,true);
	parallel(45);
	moveDistance(-100,72);
	tillBack(-100,false);
}
void reverseKickstand() {
	tillFront(-50,true);
	tillBack(-50, false);
	moveDistance(50, 9);
	pause(0.5);
	parallel(45);
	while(true);
	moveDistance(-45,5);

	/*if(tooClose(10)){
		tillFront(-100,false);
		return;
	}*/
	reverseKnockdown();
}

task main(){
	//waitForStart();
	/*float robotLength = 29;
	while(true) {
		float diff = SensorValue[frontUltra] - SensorValue[backUltra];
		float angle = radiansToDegrees(atan(diff/robotLength));
		nxtDisplayCenteredTextLine(2,"angle: %f ", angle);
	}*/
		// the default DSP mode is 1200 Hz.
  tHTIRS2DSPMode _mode = DSP_1200;
  HTIRS2setDSPMode(HTIRS2, _mode);
  int _dirAC = HTIRS2readACDir(HTIRS2);
  int position = 1;
  if(_dirAC == 0) {
  	position = 2;
	}
	else {
		PlaySound(soundBeepBeep);
	}

	releaseTube();
	moveDistance(-100, 40);
	parallel(45);
	moveDistance(-100, 75);
	grabTube();
	moveDistance(50, 5);
	pause(0.5);
	parallel(45);
	turnDistance(100, 10);
	moveDistance(100, 85);
	pause(0.5);
	turnDistance(100, 190);
	pause(0.5);
	releaseTube();
	if(position == 2)
		kickstand();
	else if(position == 1) {
		pause(0.5);
		turnDistance(50, 70);
		reverseKickstand();
	}
}
